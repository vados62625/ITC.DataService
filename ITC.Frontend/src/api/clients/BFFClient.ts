//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class EnginesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "http://89.108.73.166:5016/";

    }

    /**
     * @param id (optional) 
     * @param engineType (optional) 
     * @param name (optional) 
     * @param engineStatus (optional) 
     * @param page (optional) 
     * @param itemsCount (optional) 
     * @return OK
     */
    enginesGet(id: string | undefined, engineType: string | undefined, name: string | undefined, engineStatus: string | undefined, page: number | undefined, itemsCount: number | undefined, signal?: AbortSignal): Promise<PageableCollectionOfEngineDto> {
        let url_ = this.baseUrl + "/Engines?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (engineType === null)
            throw new Error("The parameter 'engineType' cannot be null.");
        else if (engineType !== undefined)
            url_ += "EngineType=" + encodeURIComponent("" + engineType) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (engineStatus === null)
            throw new Error("The parameter 'engineStatus' cannot be null.");
        else if (engineStatus !== undefined)
            url_ += "EngineStatus=" + encodeURIComponent("" + engineStatus) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (itemsCount === null)
            throw new Error("The parameter 'itemsCount' cannot be null.");
        else if (itemsCount !== undefined)
            url_ += "ItemsCount=" + encodeURIComponent("" + itemsCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEnginesGet(_response);
        });
    }

    protected processEnginesGet(response: AxiosResponse): Promise<PageableCollectionOfEngineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageableCollectionOfEngineDto.fromJS(resultData200);
            return Promise.resolve<PageableCollectionOfEngineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageableCollectionOfEngineDto>(null as any);
    }

    /**
     * @param name (optional) 
     * @param file (optional) 
     * @return OK
     */
    enginesPost(name: string | undefined, file: { data: any, fileName: string} | undefined, signal?: AbortSignal): Promise<EngineDto> {
        let url_ = this.baseUrl + "/Engines?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEnginesPost(_response);
        });
    }

    protected processEnginesPost(response: AxiosResponse): Promise<EngineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EngineDto.fromJS(resultData200);
            return Promise.resolve<EngineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EngineDto>(null as any);
    }

    /**
     * @return OK
     */
    enginesPut(body: UpdateCommand, signal?: AbortSignal): Promise<EngineDto> {
        let url_ = this.baseUrl + "/Engines";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEnginesPut(_response);
        });
    }

    protected processEnginesPut(response: AxiosResponse): Promise<EngineDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EngineDto.fromJS(resultData200);
            return Promise.resolve<EngineDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EngineDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    enginesDelete(id: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/Engines?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEnginesDelete(_response);
        });
    }

    protected processEnginesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DefectDto implements IDefectDto {
    engineId?: string;
    type?: number;
    name?: string | undefined;
    history?: DefectHistoryDto[];
    id?: string;
    deletedAt?: Date | undefined;
    updatedAt?: Date | undefined;
    createdAt?: Date;

    [key: string]: any;

    constructor(data?: IDefectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.engineId = _data["engineId"];
            this.type = _data["type"];
            this.name = _data["name"];
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(DefectHistoryDto.fromJS(item));
            }
            this.id = _data["id"];
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DefectDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["engineId"] = this.engineId;
        data["type"] = this.type;
        data["name"] = this.name;
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDefectDto {
    engineId?: string;
    type?: number;
    name?: string | undefined;
    history?: DefectHistoryDto[];
    id?: string;
    deletedAt?: Date | undefined;
    updatedAt?: Date | undefined;
    createdAt?: Date;

    [key: string]: any;
}

export class DefectHistoryDto implements IDefectHistoryDto {
    date?: Date;
    probability?: number;

    [key: string]: any;

    constructor(data?: IDefectHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.probability = _data["probability"];
        }
    }

    static fromJS(data: any): DefectHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefectHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["probability"] = this.probability;
        return data;
    }
}

export interface IDefectHistoryDto {
    date?: Date;
    probability?: number;

    [key: string]: any;
}

export class EngineDto implements IEngineDto {
    isLastAnalyseHasDefect?: boolean;
    isLastAnalyseHasCriticalDefect?: boolean;
    name?: string;
    engineStatus?: number;
    engineType?: number;
    defects?: DefectDto[];
    lastAnalyseDate?: Date;
    recommendedMaintenanceDate?: Date | undefined;
    id?: string;
    deletedAt?: Date | undefined;
    updatedAt?: Date | undefined;
    createdAt?: Date;

    [key: string]: any;

    constructor(data?: IEngineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isLastAnalyseHasDefect = _data["isLastAnalyseHasDefect"];
            this.isLastAnalyseHasCriticalDefect = _data["isLastAnalyseHasCriticalDefect"];
            this.name = _data["name"];
            this.engineStatus = _data["engineStatus"];
            this.engineType = _data["engineType"];
            if (Array.isArray(_data["defects"])) {
                this.defects = [] as any;
                for (let item of _data["defects"])
                    this.defects!.push(DefectDto.fromJS(item));
            }
            this.lastAnalyseDate = _data["lastAnalyseDate"] ? new Date(_data["lastAnalyseDate"].toString()) : <any>undefined;
            this.recommendedMaintenanceDate = _data["recommendedMaintenanceDate"] ? new Date(_data["recommendedMaintenanceDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EngineDto {
        data = typeof data === 'object' ? data : {};
        let result = new EngineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isLastAnalyseHasDefect"] = this.isLastAnalyseHasDefect;
        data["isLastAnalyseHasCriticalDefect"] = this.isLastAnalyseHasCriticalDefect;
        data["name"] = this.name;
        data["engineStatus"] = this.engineStatus;
        data["engineType"] = this.engineType;
        if (Array.isArray(this.defects)) {
            data["defects"] = [];
            for (let item of this.defects)
                data["defects"].push(item.toJSON());
        }
        data["lastAnalyseDate"] = this.lastAnalyseDate ? this.lastAnalyseDate.toISOString() : <any>undefined;
        data["recommendedMaintenanceDate"] = this.recommendedMaintenanceDate ? this.recommendedMaintenanceDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEngineDto {
    isLastAnalyseHasDefect?: boolean;
    isLastAnalyseHasCriticalDefect?: boolean;
    name?: string;
    engineStatus?: number;
    engineType?: number;
    defects?: DefectDto[];
    lastAnalyseDate?: Date;
    recommendedMaintenanceDate?: Date | undefined;
    id?: string;
    deletedAt?: Date | undefined;
    updatedAt?: Date | undefined;
    createdAt?: Date;

    [key: string]: any;
}

export class PageableCollectionOfEngineDto implements IPageableCollectionOfEngineDto {
    items?: EngineDto[];
    totalCount?: number;

    [key: string]: any;

    constructor(data?: IPageableCollectionOfEngineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EngineDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PageableCollectionOfEngineDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageableCollectionOfEngineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPageableCollectionOfEngineDto {
    items?: EngineDto[];
    totalCount?: number;

    [key: string]: any;
}

export class UpdateCommand implements IUpdateCommand {
    name?: string | undefined;
    id!: string;

    [key: string]: any;

    constructor(data?: IUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateCommand {
    name?: string | undefined;
    id: string;

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}